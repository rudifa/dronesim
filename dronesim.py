#! python


import numpy as np
import matplotlib.pyplot as plt

# Constants
g = 9.81  # Acceleration due to gravity (m/s^2)
MAX_THRUST = 30.0  # Maximum thrust (N)
MAX_VELOCITY = 50.0  # Maximum velocity (m/s)

# Drone parameters
mass = 1.5  # Mass of the drone (kg)
rotor_area = 0.1  # Rotor area (m^2)
air_density = 1.225  # Air density at sea level (kg/m^3)
C_L = 1.0  # Lift coefficient (assumed constant for simplicity)
C_D = 0.1  # Drag coefficient (assumed constant for simplicity)

# Desired altitude
target_altitude = 10.0  # Target altitude to hover at (m)

# Functions to calculate forces


def calculate_lift(thrust):
    """Calculate lift force based on thrust."""
    return thrust


def calculate_weight(mass):
    """Calculate weight of the drone."""
    return mass * g


def calculate_drag(velocity):
    """Calculate drag force based on velocity."""
    return C_D * 0.5 * air_density * rotor_area * velocity**2


# Simulation parameters
time_step = 0.1  # Time step for simulation (s)
total_time = 30.0  # Total time for simulation (s)
num_steps = int(total_time / time_step)

# Initialize arrays to store results
time_array = np.linspace(0, total_time, num_steps)
altitude_array = np.zeros(num_steps)
velocity_array = np.zeros(num_steps)
thrust_array = np.zeros(num_steps)  # Array to store thrust values

# Initial conditions
thrust = 0.0  # Initial thrust generated by the rotors (N)
altitude = 0.0  # Initial altitude (m)
velocity = 0.0  # Initial velocity (m/s)

# Simulation loop
for i in range(1, num_steps):
    lift = calculate_lift(thrust)
    weight = calculate_weight(mass)

    # Thrust control logic for hovering at target altitude
    if altitude < target_altitude:
        thrust += 1.0
        if thrust > MAX_THRUST:
            thrust = MAX_THRUST
    elif altitude > target_altitude:
        thrust -= 1.0
        if thrust < weight:
            thrust = weight
    else:
        thrust = weight

    thrust_array[i] = thrust  # Store current thrust value

    # Calculate net force and ensure velocity is capped
    net_force = lift - weight - calculate_drag(min(velocity, MAX_VELOCITY))
    acceleration = net_force / mass

    # Update velocity and altitude with safety checks
    velocity += acceleration * time_step
    if abs(velocity) > MAX_VELOCITY:
        velocity = np.sign(velocity) * MAX_VELOCITY

    altitude += velocity * time_step

    # Store results
    velocity_array[i] = velocity
    altitude_array[i] = altitude

# Plotting results
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(time_array, altitude_array, label='Altitude (m)', color='blue')
plt.axhline(y=target_altitude, color='red',
            linestyle='--', label='Target Altitude')
plt.title('Drone Flight Simulation with Thrust Control')
plt.xlabel('Time (s)')
plt.ylabel('Altitude (m)')
plt.grid()
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(time_array, velocity_array, label='Velocity (m/s)', color='red')
plt.xlabel('Time (s)')
plt.ylabel('Velocity (m/s)')
plt.grid()
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(time_array, thrust_array, label='Thrust (N)', color='green')
plt.xlabel('Time (s)')
plt.ylabel('Thrust (N)')
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()
